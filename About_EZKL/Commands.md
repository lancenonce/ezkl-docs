---
order: 92
---
## `ezkl` Commands


Here is some more detail on `ezkl` commands.

### Getting an SRS

`ezkl` uses KZG commitments, which in turn require a structured reference string (SRS). You can download a [KZG](https://cypherpunks.ca/~iang/pubs/PolyCommit-AsiaCrypt.pdf) structured reference string with (for example) 17 rows as follows. 

```bash
ezkl get-srs --logrows=17 --srs-path=17.srs
```

This sets up a SRS that the prover can use to commit and the verifier can use to evaluate in a file called `17.srs`.

> **Note:** `ezkl` has a command `gen-srs` to generate an SRS for testing purposes when bandwidth is scarce. The SRS generated by `gen-srs` is not meant to be used in production.

> **Note:** Downsizing an SRS is time consuming, so if you obtain a logrows=20 SRS and the circuit uses logrows=17, the prove command will spend most of its time downsizing your 20.srs from 20 to 17. Once you know the logrows you need, use a file of that size for max speed.

### Generate Settings
For `ezkl` to compute a snark, it needs some settings to determine how to create the circuit. You can create settings with the `gen-settings` command. 

For example, this is the file generated from our CLI tutorial example:

```bash
ezkl gen-settings -M examples/onnx/4l_relu_conv_fc/network.onnx
```
By default the settings file will be called `settings.json`. 

**`settings.json`:**
```javascript
{"run_args":{
  "tolerance":{"val":0.0,"scales":[1,1]},"scale":7,"bits":16,"logrows":17,"batch_size":1,
  "input_visibility":"Private","output_visibility":"Public","param_visibility":"Private","allocated_constraints":null},
  "num_constraints":13172,"model_instance_shapes":[[1,10]],"model_output_scales":[14],"module_sizes":{"poseidon":[0,[0]],"elgamal":[0,[0,0,0]]},
  "required_lookups":[{"ReLU":{"scale":128}}],
  "check_mode":"SAFE"
  }
```
Let's say our circuit was much larger; we need to bump `"logrows"` to 23. We can add a flag to our original command to specifiy this (using `-O` to give the output a different name):

```bash
ezkl gen-settings -M examples/onnx/4l_relu_conv_fc/network.onnx -O circuitK23.json --logrows 23
```
This produces **`circuitK23.json`:** which is the same as the `settings.json` above, but with `"logrows"` now 23. You can do this for any other parameter for custom circuits. The `.json` file can also be manually edited to tweak the choices.
### Calibrate Settings
There are a lot of adjustable knobs (such as bits, scale, and logrows) in `ezkl` that let you trade off between prover and verifier resources, accuracy, and control other parts of the zkp setup. While you are free to choose these manually with cli parameters passed to `gen-settings`, we recommend fine-tuning with the automatic calibration provided by the `calibrate-settings` command. This modifies your `settings.json` file with a suggested choice of circuit parameters: 

```bash
ezkl calibrate-settings -M examples/onnx/4l_relu_conv_fc/network.onnx -D examples/onnx/4l_relu_conv_fc/input.json --target resources
```

You can also set the `--target` to **"accuracy"** if you want to optimize for numerical accuracy rather than CPU and memory performance. The default is set to **"resources"**. The largest tradeoff for these two is in the size of `"logrows"` and `"scale"`. With a higher scale, floating point numbers are interpreted more accurately. With a smaller logrows, a smaller, less memory-intensive circuit is generated. 

For example, after running the same command with `--target` set to **accuracy**, we get a larger value for `scale` amongst other changes:

**settings.json**:
```javascript
{"run_args":{"tolerance":{"val":0.0,"scales":[1,1]},"scale":11,"bits":21,"logrows":22,"batch_size":1,"input_visibility":"Private","output_visibility":"Public","param_visibility":"Private","allocated_constraints":null},
"num_constraints":13172,"model_instance_shapes":[[1,10]],"model_output_scales":[22],"module_sizes":{"poseidon":[0,[0]],"elgamal":[0,[0,0,0]]},
"required_lookups":[{"ReLU":{"scale":2048}}],
"check_mode":"SAFE"}
```

> Note: You can still use the generic RunArgs for `mock` and `gen-witness` (e.g. `ezkl mock --logrows=22 --bits=21` rather than `ezkl mock --settings-path circuit.json`). However, `--settings-path` takes priority.

### Compile model
This converts and freezes the onnx file to what ezkl will actually prove against, incorporating the settings, quantizing, etc. 

```bash
ezkl compile-model -M network.onnx -S settings.json --compiled-model network.ezkl
```

### Setup

Along with our SRS and circuit parameters, we need two other elements to generate a proof: a proving key and a verifying key. You will get both by running `ezkl`'s `setup` command. We need our proving key to generate proofs; we need our verifying key to verify proofs from the corresponding proving key, or to generate an EVM verifier.

Run this command to set up your proving and verifying keys:

```bash
ezkl setup -M network.ezkl --srs-path=17.srs  --settings-path=settings.json
```
You should now have files called `vk.key` and `pk.key` in the root of your project. You can also specify different paths for these outputs with `--vk-path=altvk.key --pk-path=altpk.key`

### Generate witness

Now we take the input data, quantize it, and run it through the quantized model, performing any hashing or encryption, to obtain the input and output that we will be proving. 

```bash
ezkl gen-witness -M network.ezkl -D examples/onnx/4l_relu_conv_fc/input.json  --settings-path settings.json
```
The default output file is `witness.json`.

### Prove

Now that we have all the parameters, we can generate our proof.

In a typical zk application, the proof will be generated by or on behalf of the client, then verified on a blockchain or server. `ezkl` provides WASM bindings for `prove` that you can use to generate proofs in-browser. 

Here is the command for generating a proof from the cli:

```bash
ezkl prove -M network.ezkl --witness witness.json --pk-path=pk.key --proof-path=model.proof --srs-path=15.srs --settings-path=settings.json
```

This will create a proof file called `model.proof` that anyone can later use to verify your model was run correctly on the input.

### Verify

Verification can be done from the CLI, in WASM, or on a blockchain. Verification will require the commitment scheme parameters, the circuit parameters, the verifying key, and, of course, the proof. When verifying with a smart contract, however, the verifying key and circuit/commitment params are baked into the smart contract; this means only the public parameters will be passed as calldata along with the proof. The command for verifying from the CLI is:

```bash
ezkl verify --proof-path=model.proof --settings-path=settings.json --vk-path=vk.key --srs-path=15.srs
```

This will return whether your proof has successfully verified or not. Refer to Verifying On-Chain section to verify with an EVM smart contract. 

[!ref](/verifying_on-chain)


_________________

Note that these are not the only operations that can be performed by `ezkl`. You can also run a `Mock` proof to see if a proof will verify, or run the `Table` command to see a table of all your onnx operations that your SNARK will consist of. The table command is helpful in determining if `ezkl` knows how to snark your model. You can also run `Fuzz` to fuzz test your SNARK on random inputs. Even our EVM commands can take in `RunArgs` to specify how an evm verifier will be created. Let's look into the rest of these in detail.

### Mock

When you're testing a model, you may not want to run `setup` and `prove` with each iteration. `ezkl` provides a simple alternative with `mock`, where you can convert your model to constraints and run the inputs tosee if a proof can be generated. This saves time when testing new iterations of models with potential issues. Here is the command for `mock`:

```bash
ezkl mock -M network.ezkl --witness witness.json --settings-path=settings.json
```

Mock is basically checking that constraints that your model has been translated into are satisfied, without doing any of the subsequent cryptographic heavy lifting to produce a proof. 

### Generate Witness

The `gen-witness` function generates a witness for a given model and input data for a neural net or computational graph. A witness in the context of Zero Knowledge Proofs is a computational trace that allows a proof to be generated.  The `gen-witness` function doesn't record all the intermediate values of the trace (such as the activations of inner layers in a neural network), but does write the final outputs of your neural network or computation graph in a form that is usable in the prove command, and human readable.

The function has additional configurable settings, including an ONNX model file path, an input data file path, an output file path, an optional scale, and an optional batch size. More details on the optional scale and optional batch size can be found in [RunArgs](./RunArgs.md).

```bash
ezkl gen-witness -M network.ezkl -D examples/onnx/1l_sigmoid/input.json
```

### Table

`ezkl`'s `table` command enables users to get their model's operations, inputs, and outputs in an intuitive format. Calling this command:

```bash
ezkl table -M examples/onnx/1l_sigmoid/network.onnx
```

will produce a table that looks like:

```bash
 |	┌─────────┬───────────┬────────┬──────────┬─────┐
 |  │ opkind  │ out_scale │ inputs │ out_dims │ idx │
 |  ├─────────┼───────────┼────────┼──────────┼─────┤
 |  │ Input   │ 7         │        │ [1, 3]   │ 0   │
 |  ├─────────┼───────────┼────────┼──────────┼─────┤
 |  │ SIGMOID │ 7         │ [0]    │ [1, 3]   │ 1   │
 |  └─────────┴───────────┴────────┴──────────┴─────┘
```

You can use `table` with your model to know exactly which operations your model uses. If the operation is unsupported, you may see an `Unknown` in the table, and get a warning. This means the op isn't available in ezkl, and you should file an issue to request its implementation.

### Render

`halo2` provides a service you can use to render a `.png` of your circuit layout, which can be useful in debugging. First install the binaries with the `render` feature enabled: 

```bash
cargo install --force --path . --features=render
```

Then, run this command:

```bash
ezkl render-circuit -M examples/onnx/1l_sigmoid/network.onnx -O examples/onnx/1l_sigmoid/render.png
```

This will render our circuit as a file named `render.png` in our `examples/onnx/1l_sigmoid` directory. 

![image-20230608155046296](../assets/sigmoidrender.png)

In this image,

- Pink columns represent advice values
- White columns represent instance values
- Purple/blue columns represent fixed values
- Green areas represent regions in our circuit


### Aggregate

This step is described briefly in the `Verifying On-Chain` section. Here, we'll describe `aggregate` with more detail. 

We can aggregate multiple proofs into one with the `aggregate` command. Let's make two new circuits: one that produces a proof called `model.proof` and another that produces a proof called `model1.proof`. In aggregation, we want to use a large circuit because we're dealing with multiple proofs. Let's set up a SRS of size `k=23` :

```bash
ezkl gen-srs --logrows 23 --srs-path=23.srs
```

Now, let's say we want to aggregate a `conv` circuit and a `relu` circuit. We can set up the parameters for these different circuits with `gen-circuit-params`. For the sake of the example, let's set one to optimize for accuracy and another to optimize for resources:
```bash
ezkl gen-settings --model examples/onnx/1l_conv/network.onnx --settings-path circuitconv.json
ezkl calibrate-settings -M examples/onnx/1l_conv/network.onnx -D examples/onnx/1l_conv/input.json --target accuracy -O circuitconv.json
```
and for RELU:
```bash
ezkl gen-settings --model examples/onnx/1l_relu/network.onnx --settings-path circuitrelu.json
ezkl calibrate-settings -M examples/onnx/1l_relu/network.onnx -D examples/onnx/1l_relu/input.json --target resources -O circuitrelu.json
```

Now, we can create our proof keys with `setup` (Note: be sure to use the same KZG parameters for all the circuits you plan to aggregate):

```bash
# Conv
ezkl compile-model -M examples/onnx/1l_conv/network.onnx --settings-path=circuitconv.json --compiled-model conv.ezkl
ezkl setup -M conv.ezkl --srs-path=23.srs --vk-path=vkconv.key --pk-path=pkconv.key --settings-path=circuitconv.json
```

```bash
# Relu
ezkl compile-model -M examples/onnx/1l_relu/network.onnx --settings-path=circuitconv.json --compiled-model relu.ezkl
ezkl setup -M relu.ezkl --srs-path=23.srs --vk-path=vkrelu.key --pk-path=pkrelu.key --settings-path=circuitrelu.json
```

We then prove them.

```bash
# Conv
ezkl gen-witness -D ./examples/onnx/1l_conv/input.json -M conv.ezkl -O convwit.json --settings-path=circuitconv.json 
ezkl prove --transcript=poseidon --strategy=accum --witness convwit.json -M conv.ezkl --proof-path conv.proof --srs-path=23.srs  --pk-path=pkconv.key --settings-path=circuitconv.json
```

```bash
# Relu
ezkl gen-witness -D ./examples/onnx/1l_relu/input.json -M relu.ezkl -O reluwit.json --settings-path=circuitrelu.json
ezkl prove --transcript=poseidon --strategy=accum --witness reluwit.json -M relu.ezkl --proof-path relu.proof --srs-path=23.srs  --pk-path=pkrelu.key --settings-path=circuitrelu.json
```

Setup the aggregation:
```bash
ezkl setup-aggregate --sample-snarks conv.proof --sample-snarks relu.proof --srs-path 23.srs --logrows 23
```

Now, we can aggregate the proofs:

```bash
ezkl aggregate --logrows=23 --aggregation-snarks=conv.proof --aggregation-snarks=relu.proof --proof-path aggr.proof --srs-path=23.srs --pk-path pk_aggr.key 
```

This creates one proof that simultaneously proves both our `conv` and `relu` circuits as long as we pass both proofs and verifying keys in. The bad news is that computing an aggregation takes a lot of memory and time right now; this proof will probably take about four or five minutes.

### VerifyAggr

Now, we can verify our aggregated proof with:

```bash
ezkl verify-aggr --logrows=23 --proof-path aggr.proof --srs-path=23.srs --vk-path vk_aggr.key
```

This should return `verified: true`. You can learn more about aggregation [here](https://vitalik.ca/general/2021/11/05/halo.html).

### Fuzz

You can learn more about `fuzz` in the Security section under **EZKL Security Tooling**. 

